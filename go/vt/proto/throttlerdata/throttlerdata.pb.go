// Code generated by protoc-gen-go.
// source: throttlerdata.proto
// DO NOT EDIT!

/*
Package throttlerdata is a generated protocol buffer package.

It is generated from these files:
	throttlerdata.proto

It has these top-level messages:
	MaxRatesRequest
	MaxRatesResponse
	SetMaxRateRequest
	SetMaxRateResponse
	Configuration
	GetConfigurationRequest
	GetConfigurationResponse
	UpdateConfigurationRequest
	UpdateConfigurationResponse
	ResetConfigurationRequest
	ResetConfigurationResponse
*/
package throttlerdata

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// MaxRatesRequest is the payload for the MaxRates RPC.
type MaxRatesRequest struct {
}

func (m *MaxRatesRequest) Reset()                    { *m = MaxRatesRequest{} }
func (m *MaxRatesRequest) String() string            { return proto.CompactTextString(m) }
func (*MaxRatesRequest) ProtoMessage()               {}
func (*MaxRatesRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// MaxRatesResponse is returned by the MaxRates RPC.
type MaxRatesResponse struct {
	// max_rates returns the max rate for each throttler. It's keyed by the
	// throttler name.
	Rates map[string]int64 `protobuf:"bytes,1,rep,name=rates" json:"rates,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
}

func (m *MaxRatesResponse) Reset()                    { *m = MaxRatesResponse{} }
func (m *MaxRatesResponse) String() string            { return proto.CompactTextString(m) }
func (*MaxRatesResponse) ProtoMessage()               {}
func (*MaxRatesResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *MaxRatesResponse) GetRates() map[string]int64 {
	if m != nil {
		return m.Rates
	}
	return nil
}

// SetMaxRateRequest is the payload for the SetMaxRate RPC.
type SetMaxRateRequest struct {
	Rate int64 `protobuf:"varint,1,opt,name=rate" json:"rate,omitempty"`
}

func (m *SetMaxRateRequest) Reset()                    { *m = SetMaxRateRequest{} }
func (m *SetMaxRateRequest) String() string            { return proto.CompactTextString(m) }
func (*SetMaxRateRequest) ProtoMessage()               {}
func (*SetMaxRateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// SetMaxRateResponse is returned by the SetMaxRate RPC.
type SetMaxRateResponse struct {
	// names is the list of throttler names which were updated.
	Names []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
}

func (m *SetMaxRateResponse) Reset()                    { *m = SetMaxRateResponse{} }
func (m *SetMaxRateResponse) String() string            { return proto.CompactTextString(m) }
func (*SetMaxRateResponse) ProtoMessage()               {}
func (*SetMaxRateResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// Configuration holds the configuration parameters for the
// MaxReplicationLagModule which adaptively adjusts the throttling rate based on
// the observed replication lag across all replicas.
type Configuration struct {
	// target_replication_lag_sec is the replication lag (in seconds) the
	// MaxReplicationLagModule tries to aim for.
	// If it is within the target, it tries to increase the throttler
	// rate, otherwise it will lower it based on an educated guess of the
	// slave throughput.
	TargetReplicationLagSec int64 `protobuf:"varint,1,opt,name=target_replication_lag_sec,json=targetReplicationLagSec" json:"target_replication_lag_sec,omitempty"`
	// max_replication_lag_sec is meant as a last resort.
	// By default, the module tries to find out the system maximum capacity while
	// trying to keep the replication lag around "target_replication_lag_sec".
	// Usually, we'll wait min_duration_between_(increases|decreases)_sec to see
	// the effect of a throttler rate change on the replication lag.
	// But if the lag goes above this field's value we will go into an "emergency"
	// state and throttle more aggressively (see "emergency_decrease" below).
	// This is the only way to ensure that the system will recover.
	MaxReplicationLagSec int64 `protobuf:"varint,2,opt,name=max_replication_lag_sec,json=maxReplicationLagSec" json:"max_replication_lag_sec,omitempty"`
	// initial_rate is the rate at which the module will start.
	InitialRate int64 `protobuf:"varint,3,opt,name=initial_rate,json=initialRate" json:"initial_rate,omitempty"`
	// max_increase defines by how much we will increase the rate
	// e.g. 0.05 increases the rate by 5% while 1.0 by 100%.
	// Note that any increase will let the system wait for at least
	// (1 / MaxIncrease) seconds. If we wait for shorter periods of time, we
	// won't notice if the rate increase also increases the replication lag.
	// (If the system was already at its maximum capacity (e.g. 1k QPS) and we
	// increase the rate by e.g. 5% to 1050 QPS, it will take 20 seconds until
	// 1000 extra queries are buffered and the lag increases by 1 second.)
	MaxIncrease float64 `protobuf:"fixed64,4,opt,name=max_increase,json=maxIncrease" json:"max_increase,omitempty"`
	// emergency_decrease defines by how much we will decrease the current rate
	// if the observed replication lag is above "max_replication_lag_sec".
	// E.g. 0.50 decreases the current rate by 50%.
	EmergencyDecrease float64 `protobuf:"fixed64,5,opt,name=emergency_decrease,json=emergencyDecrease" json:"emergency_decrease,omitempty"`
	// min_duration_between_increases_sec specifies how long we'll wait at least
	// for the last rate increase to have an effect on the system.
	MinDurationBetweenIncreasesSec int64 `protobuf:"varint,6,opt,name=min_duration_between_increases_sec,json=minDurationBetweenIncreasesSec" json:"min_duration_between_increases_sec,omitempty"`
	// max_duration_between_increases_sec specifies how long we'll wait at most
	// for the last rate increase to have an effect on the system.
	MaxDurationBetweenIncreasesSec int64 `protobuf:"varint,7,opt,name=max_duration_between_increases_sec,json=maxDurationBetweenIncreasesSec" json:"max_duration_between_increases_sec,omitempty"`
	// min_duration_between_decreases_sec specifies how long we'll wait at least
	// for the last rate decrease to have an effect on the system.
	MinDurationBetweenDecreasesSec int64 `protobuf:"varint,8,opt,name=min_duration_between_decreases_sec,json=minDurationBetweenDecreasesSec" json:"min_duration_between_decreases_sec,omitempty"`
	// spread_backlog_across_sec is used when we set the throttler rate after
	// we guessed the rate of a slave and determined its backlog.
	// For example, at a guessed rate of 100 QPS and a lag of 10s, the replica has
	// a backlog of 1000 queries.
	// When we set the new, decreased throttler rate, we factor in how long it
	// will take the slave to go through the backlog (in addition to new
	// requests). This field specifies over which timespan we plan to spread this.
	// For example, for a backlog of 1000 queries spread over 5s means that we
	// have to further reduce the rate by 200 QPS or the backlog will not be
	// processed within the 5 seconds.
	SpreadBacklogAcrossSec int64 `protobuf:"varint,9,opt,name=spread_backlog_across_sec,json=spreadBacklogAcrossSec" json:"spread_backlog_across_sec,omitempty"`
	// ignore_n_slowest_replicas will ignore replication lag updates from the
	// N slowest replicas. Under certain circumstances, replicas are still
	// considered e.g. a) if the lag is at most max_replication_lag_sec, b) there
	// are less than N+1 replicas or c) the lag increased on each replica such
	// that all replicas were ignored in a row.
	IgnoreNSlowestReplicas int32 `protobuf:"varint,10,opt,name=ignore_n_slowest_replicas,json=ignoreNSlowestReplicas" json:"ignore_n_slowest_replicas,omitempty"`
	// age_bad_rate_after_sec is the duration after which an unchanged bad rate
	// will "age out" and increase by "bad_rate_increase".
	// Bad rates are tracked by the code in memory.go and serve as an upper bound
	// for future rate changes. This ensures that the adaptive throttler does not
	// try known too high (bad) rates over and over again.
	// To avoid that temporary degradations permanently reduce the maximum rate,
	// a stable bad rate "ages out" after "age_bad_rate_after_sec".
	AgeBadRateAfterSec int64 `protobuf:"varint,11,opt,name=age_bad_rate_after_sec,json=ageBadRateAfterSec" json:"age_bad_rate_after_sec,omitempty"`
	// bad_rate_increase defines the percentage by which a bad rate will be
	// increased when it's aging out.
	BadRateIncrease float64 `protobuf:"fixed64,12,opt,name=bad_rate_increase,json=badRateIncrease" json:"bad_rate_increase,omitempty"`
}

func (m *Configuration) Reset()                    { *m = Configuration{} }
func (m *Configuration) String() string            { return proto.CompactTextString(m) }
func (*Configuration) ProtoMessage()               {}
func (*Configuration) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

// GetConfigurationRequest is the payload for the GetConfiguration RPC.
type GetConfigurationRequest struct {
	// throttler_name specifies which throttler to select. If empty, all active
	// throttlers will be selected.
	ThrottlerName string `protobuf:"bytes,1,opt,name=throttler_name,json=throttlerName" json:"throttler_name,omitempty"`
}

func (m *GetConfigurationRequest) Reset()                    { *m = GetConfigurationRequest{} }
func (m *GetConfigurationRequest) String() string            { return proto.CompactTextString(m) }
func (*GetConfigurationRequest) ProtoMessage()               {}
func (*GetConfigurationRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

// GetConfigurationResponse is returned by the GetConfiguration RPC.
type GetConfigurationResponse struct {
	// max_rates returns the configurations for each throttler.
	// It's keyed by the throttler name.
	Configurations map[string]*Configuration `protobuf:"bytes,1,rep,name=configurations" json:"configurations,omitempty" protobuf_key:"bytes,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *GetConfigurationResponse) Reset()                    { *m = GetConfigurationResponse{} }
func (m *GetConfigurationResponse) String() string            { return proto.CompactTextString(m) }
func (*GetConfigurationResponse) ProtoMessage()               {}
func (*GetConfigurationResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GetConfigurationResponse) GetConfigurations() map[string]*Configuration {
	if m != nil {
		return m.Configurations
	}
	return nil
}

// UpdateConfigurationRequest is the payload for the UpdateConfiguration RPC.
type UpdateConfigurationRequest struct {
	// throttler_name specifies which throttler to update. If empty, all active
	// throttlers will be updated.
	ThrottlerName string `protobuf:"bytes,1,opt,name=throttler_name,json=throttlerName" json:"throttler_name,omitempty"`
	// configuration is the new (partial) configuration.
	Configuration *Configuration `protobuf:"bytes,2,opt,name=configuration" json:"configuration,omitempty"`
	// copy_zero_values specifies whether fields with zero values should be copied
	// as well.
	CopyZeroValues bool `protobuf:"varint,3,opt,name=copy_zero_values,json=copyZeroValues" json:"copy_zero_values,omitempty"`
}

func (m *UpdateConfigurationRequest) Reset()                    { *m = UpdateConfigurationRequest{} }
func (m *UpdateConfigurationRequest) String() string            { return proto.CompactTextString(m) }
func (*UpdateConfigurationRequest) ProtoMessage()               {}
func (*UpdateConfigurationRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *UpdateConfigurationRequest) GetConfiguration() *Configuration {
	if m != nil {
		return m.Configuration
	}
	return nil
}

// UpdateConfigurationResponse is returned by the UpdateConfiguration RPC.
type UpdateConfigurationResponse struct {
	// names is the list of throttler names which were updated.
	Names []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
}

func (m *UpdateConfigurationResponse) Reset()                    { *m = UpdateConfigurationResponse{} }
func (m *UpdateConfigurationResponse) String() string            { return proto.CompactTextString(m) }
func (*UpdateConfigurationResponse) ProtoMessage()               {}
func (*UpdateConfigurationResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

// ResetConfigurationRequest is the payload for the ResetConfiguration RPC.
type ResetConfigurationRequest struct {
	// throttler_name specifies which throttler to reset. If empty, all active
	// throttlers will be reset.
	ThrottlerName string `protobuf:"bytes,1,opt,name=throttler_name,json=throttlerName" json:"throttler_name,omitempty"`
}

func (m *ResetConfigurationRequest) Reset()                    { *m = ResetConfigurationRequest{} }
func (m *ResetConfigurationRequest) String() string            { return proto.CompactTextString(m) }
func (*ResetConfigurationRequest) ProtoMessage()               {}
func (*ResetConfigurationRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

// ResetConfigurationResponse is returned by the ResetConfiguration RPC.
type ResetConfigurationResponse struct {
	// names is the list of throttler names which were updated.
	Names []string `protobuf:"bytes,1,rep,name=names" json:"names,omitempty"`
}

func (m *ResetConfigurationResponse) Reset()                    { *m = ResetConfigurationResponse{} }
func (m *ResetConfigurationResponse) String() string            { return proto.CompactTextString(m) }
func (*ResetConfigurationResponse) ProtoMessage()               {}
func (*ResetConfigurationResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func init() {
	proto.RegisterType((*MaxRatesRequest)(nil), "throttlerdata.MaxRatesRequest")
	proto.RegisterType((*MaxRatesResponse)(nil), "throttlerdata.MaxRatesResponse")
	proto.RegisterType((*SetMaxRateRequest)(nil), "throttlerdata.SetMaxRateRequest")
	proto.RegisterType((*SetMaxRateResponse)(nil), "throttlerdata.SetMaxRateResponse")
	proto.RegisterType((*Configuration)(nil), "throttlerdata.Configuration")
	proto.RegisterType((*GetConfigurationRequest)(nil), "throttlerdata.GetConfigurationRequest")
	proto.RegisterType((*GetConfigurationResponse)(nil), "throttlerdata.GetConfigurationResponse")
	proto.RegisterType((*UpdateConfigurationRequest)(nil), "throttlerdata.UpdateConfigurationRequest")
	proto.RegisterType((*UpdateConfigurationResponse)(nil), "throttlerdata.UpdateConfigurationResponse")
	proto.RegisterType((*ResetConfigurationRequest)(nil), "throttlerdata.ResetConfigurationRequest")
	proto.RegisterType((*ResetConfigurationResponse)(nil), "throttlerdata.ResetConfigurationResponse")
}

func init() { proto.RegisterFile("throttlerdata.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 658 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xa4, 0x55, 0x5d, 0x4f, 0x13, 0x4d,
	0x14, 0xce, 0x52, 0xca, 0x0b, 0xa7, 0x7c, 0x75, 0x20, 0x50, 0xfa, 0x1a, 0x53, 0x37, 0x31, 0x36,
	0x24, 0xf6, 0xa2, 0xc4, 0x04, 0xe5, 0x06, 0x2a, 0xc6, 0x68, 0x94, 0x8b, 0x25, 0x7a, 0xe1, 0xcd,
	0xe4, 0x74, 0xf7, 0xb0, 0x6e, 0xd8, 0x2f, 0x67, 0x06, 0x69, 0xfd, 0x11, 0xfe, 0x17, 0xfd, 0x45,
	0xfe, 0x14, 0xb3, 0x33, 0xd3, 0x8f, 0x2d, 0x05, 0x4c, 0xb8, 0xdb, 0x39, 0xe7, 0x99, 0xe7, 0x3c,
	0x67, 0xce, 0x3c, 0xb3, 0xb0, 0xa5, 0xbe, 0x8a, 0x4c, 0xa9, 0x98, 0x44, 0x80, 0x0a, 0x3b, 0xb9,
	0xc8, 0x54, 0xc6, 0xd6, 0x4a, 0x41, 0xb7, 0x0e, 0x1b, 0x1f, 0x71, 0xe0, 0xa1, 0x22, 0xe9, 0xd1,
	0xb7, 0x2b, 0x92, 0xca, 0xfd, 0xe9, 0xc0, 0xe6, 0x24, 0x26, 0xf3, 0x2c, 0x95, 0xc4, 0x8e, 0xa1,
	0x2a, 0x8a, 0x40, 0xc3, 0x69, 0x55, 0xda, 0xb5, 0xee, 0x7e, 0xa7, 0xcc, 0x3d, 0x8b, 0xef, 0xe8,
	0xd5, 0x9b, 0x54, 0x89, 0xa1, 0x67, 0x36, 0x36, 0x0f, 0x01, 0x26, 0x41, 0xb6, 0x09, 0x95, 0x4b,
	0x1a, 0x36, 0x9c, 0x96, 0xd3, 0x5e, 0xf1, 0x8a, 0x4f, 0xb6, 0x0d, 0xd5, 0xef, 0x18, 0x5f, 0x51,
	0x63, 0xa1, 0xe5, 0xb4, 0x2b, 0x9e, 0x59, 0xbc, 0x5a, 0x38, 0x74, 0xdc, 0x67, 0x50, 0x3f, 0x27,
	0x65, 0x4b, 0x58, 0x95, 0x8c, 0xc1, 0x62, 0xc1, 0xab, 0x19, 0x2a, 0x9e, 0xfe, 0x76, 0xf7, 0x81,
	0x4d, 0x03, 0xad, 0xf4, 0x6d, 0xa8, 0xa6, 0x98, 0x58, 0xe9, 0x2b, 0x9e, 0x59, 0xb8, 0xbf, 0xab,
	0xb0, 0xf6, 0x3a, 0x4b, 0x2f, 0xa2, 0xf0, 0x4a, 0xa0, 0x8a, 0xb2, 0x94, 0x1d, 0x41, 0x53, 0xa1,
	0x08, 0x49, 0x71, 0x41, 0x79, 0x1c, 0xf9, 0x3a, 0xca, 0x63, 0x0c, 0xb9, 0x24, 0xdf, 0xd6, 0xd9,
	0x35, 0x08, 0x6f, 0x02, 0xf8, 0x80, 0xe1, 0x39, 0xf9, 0xec, 0x05, 0xec, 0x26, 0x38, 0x98, 0xbb,
	0xd3, 0xf4, 0xb3, 0x9d, 0xe0, 0xe0, 0xe6, 0xb6, 0x27, 0xb0, 0x1a, 0xa5, 0x91, 0x8a, 0x30, 0xe6,
	0xba, 0x9b, 0x8a, 0xc6, 0xd6, 0x6c, 0xac, 0x68, 0xa3, 0x80, 0x14, 0xcc, 0x51, 0xea, 0x0b, 0x42,
	0x49, 0x8d, 0xc5, 0x96, 0xd3, 0x76, 0xbc, 0x5a, 0x82, 0x83, 0x77, 0x36, 0xc4, 0x9e, 0x03, 0xa3,
	0x84, 0x44, 0x48, 0xa9, 0x3f, 0xe4, 0x01, 0x59, 0x60, 0x55, 0x03, 0xeb, 0xe3, 0xcc, 0xa9, 0x4d,
	0xb0, 0xf7, 0xe0, 0x26, 0x51, 0xca, 0x03, 0xdb, 0x38, 0xef, 0x93, 0xba, 0x26, 0x4a, 0xc7, 0x25,
	0xa4, 0x96, 0xbd, 0xa4, 0xa5, 0x3c, 0x4e, 0xa2, 0xf4, 0xd4, 0x02, 0x7b, 0x06, 0x37, 0x2a, 0x2b,
	0x8b, 0x06, 0x0a, 0x2e, 0x1c, 0xdc, 0xc7, 0xf5, 0x9f, 0xe5, 0xc2, 0xc1, 0x7d, 0x5c, 0xf3, 0x74,
	0x8d, 0x3a, 0x32, 0x5c, 0xcb, 0xb7, 0xe9, 0x1a, 0xf5, 0xa7, 0xb9, 0x5e, 0xc2, 0x9e, 0xcc, 0x05,
	0x61, 0xc0, 0xfb, 0xe8, 0x5f, 0xc6, 0x59, 0xc8, 0xd1, 0x17, 0x99, 0x34, 0x14, 0x2b, 0x9a, 0x62,
	0xc7, 0x00, 0x7a, 0x26, 0x7f, 0xa2, 0xd3, 0x76, 0x6b, 0x14, 0xa6, 0x99, 0x20, 0x9e, 0x72, 0x19,
	0x67, 0xd7, 0x24, 0xc7, 0x37, 0x42, 0x36, 0xa0, 0xe5, 0xb4, 0xab, 0xde, 0x8e, 0x01, 0x9c, 0x9d,
	0x9b, 0xb4, 0x9d, 0xab, 0x64, 0x5d, 0xd8, 0xc1, 0x90, 0x78, 0x1f, 0x03, 0x3d, 0x4e, 0x8e, 0x17,
	0x8a, 0x84, 0x2e, 0x59, 0xd3, 0x25, 0x19, 0x86, 0xd4, 0xc3, 0xa0, 0x98, 0xeb, 0x49, 0x91, 0x2a,
	0xca, 0xed, 0x43, 0x7d, 0x8c, 0x1f, 0x0f, 0x79, 0x55, 0xcf, 0x6e, 0xa3, 0x6f, 0xb0, 0xa3, 0x53,
	0x72, 0x8f, 0x61, 0xf7, 0x2d, 0xa9, 0xd2, 0xb5, 0x1d, 0xf9, 0xe1, 0x29, 0xac, 0x8f, 0x2d, 0xc9,
	0x8b, 0x2b, 0x6e, 0xbd, 0x35, 0xf1, 0xfb, 0x19, 0x26, 0xe4, 0xfe, 0x71, 0xa0, 0x71, 0x93, 0xc2,
	0x3a, 0xc5, 0x87, 0x75, 0x7f, 0x3a, 0x31, 0x72, 0xfb, 0xd1, 0x8c, 0xdb, 0x6f, 0x23, 0xe8, 0x94,
	0xa2, 0xd6, 0xfe, 0x33, 0x94, 0x4d, 0x0e, 0x5b, 0x73, 0x60, 0x73, 0x1e, 0x84, 0xee, 0xf4, 0x83,
	0x50, 0xeb, 0x3e, 0x9a, 0x11, 0x51, 0x56, 0x30, 0xf5, 0x5c, 0xfc, 0x72, 0xa0, 0xf9, 0x29, 0x0f,
	0x50, 0xd1, 0x03, 0x0e, 0x8a, 0xf5, 0x60, 0xad, 0x24, 0xfc, 0x9f, 0x54, 0x94, 0xb7, 0xb0, 0x36,
	0x6c, 0xfa, 0x59, 0x3e, 0xe4, 0x3f, 0x48, 0x64, 0x5c, 0x0b, 0x94, 0xda, 0xe1, 0xcb, 0xc5, 0xa1,
	0xe4, 0xc3, 0x2f, 0x24, 0xb2, 0xcf, 0x3a, 0xea, 0x1e, 0xc0, 0xff, 0x73, 0x25, 0xdf, 0xf9, 0x84,
	0xf5, 0x60, 0xcf, 0x23, 0xf9, 0xb0, 0xfb, 0xd0, 0x85, 0xe6, 0x3c, 0x8e, 0xbb, 0xea, 0xf6, 0x97,
	0xf4, 0x9f, 0xe4, 0xe0, 0x6f, 0x00, 0x00, 0x00, 0xff, 0xff, 0x5a, 0x18, 0x19, 0x7c, 0x60, 0x06,
	0x00, 0x00,
}
